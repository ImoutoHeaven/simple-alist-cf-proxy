diff --git a/README.md b/README.md
index c4a90d3..0a4bf84 100644
--- a/README.md
+++ b/README.md
@@ -4,7 +4,7 @@ A Cloudflare Worker that acts as a download proxy for AList, with signature veri
 
 ## Features
 
-- **Four-Layer Signature Verification**: Verifies sign, hashSign, workerSign, and ipSign parameters
+- **Origin-Bound Verification**: Verifies sign, hashSign, workerSign, and an AES-GCM encrypted origin snapshot
 - **Path-based Access Control**: Blacklist/whitelist with flexible actions
 - **IPv4-only Mode**: Option to block IPv6 access
 - **Environment-based Configuration**: No hardcoded values, fully configurable via environment variables
@@ -15,8 +15,8 @@ A Cloudflare Worker that acts as a download proxy for AList, with signature veri
 This worker is designed to work with `alist-landing-worker`:
 
 1. User requests file from `alist-landing-worker`
-2. Landing worker generates four signatures and redirects to this proxy worker
-3. Proxy worker verifies all signatures
+2. Landing worker generates multiple signatures and encrypts the origin snapshot before redirecting to this proxy worker
+3. Proxy worker verifies all signatures, decrypts the snapshot, and enforces `CHECK_ORIGIN`
 4. Proxy worker fetches download URL from AList API
 5. Proxy worker streams the file to user
 
@@ -67,7 +67,7 @@ wrangler deploy
 | `SIGN_CHECK` | Plain | ❌ No | `true` | Enable ?sign= verification |
 | `HASH_CHECK` | Plain | ❌ No | `true` | Enable ?hashSign= verification |
 | `WORKER_CHECK` | Plain | ❌ No | `true` | Enable ?workerSign= verification |
-| `IP_CHECK` | Plain | ❌ No | `true` | Enable ipSign verification |
+| `CHECK_ORIGIN` | Plain | ❌ No | `""` | Comma-separated origin fields to enforce (`ip`, `iprange`, `country`, `continent`, `region`, `city`, `asn`) |
 | `IPV4_ONLY` | Plain | ❌ No | `true` | Block IPv6 access |
 | `BLACKLIST_PREFIX` | Plain | ❌ No | - | Comma-separated blacklist path prefixes |
 | `BLACKLIST_ACTION` | Plain | ❌ No | - | Action for blacklisted paths |
@@ -76,27 +76,31 @@ wrangler deploy
 | `EXCEPT_PREFIX` | Plain | ❌ No | - | Comma-separated exception path prefixes |
 | `EXCEPT_ACTION` | Plain | ❌ No | - | Exception action (must use -except suffix) |
 
-## Signature Verification
+## Signature & Origin Verification
 
-This worker verifies four signatures in order:
+This worker validates three HMAC signatures in order:
 
-1. **sign**: `HMAC-SHA256(path, expire)`
-   - Verifies the path hasn't been tampered with
+1. **sign**: `HMAC-SHA256(path, expire)` ensures the requested path was not altered.
+2. **hashSign**: `HMAC-SHA256(base64(path), expire)` adds a second integrity layer.
+3. **workerSign**: `HMAC-SHA256(JSON.stringify({path, worker_addr}), expire)` binds the ticket to a specific download worker.
 
-2. **hashSign**: `HMAC-SHA256(base64(path), expire)`
-   - Additional path integrity check
+After the HMAC chain succeeds, `additionalInfo` is verified (path hash + expiry) and, when `CHECK_ORIGIN` is non-empty, the worker decrypts `additionalInfo.encrypt` via AES-256-GCM to obtain the origin snapshot issued by the landing worker:
 
-3. **workerSign**: `HMAC-SHA256(JSON.stringify({path, worker_addr}), expire)`
-   - Binds download to specific worker address and path
-   - Prevents signature reuse across different workers
-
-4. **ipSign**: `HMAC-SHA256(JSON.stringify({path, ip}), expire)`
-   - Binds download to specific IP and path
-   - Prevents signature reuse across different files
+```jsonc
+{
+  "ip_addr": "1.2.3.4",
+  "country": "US",
+  "continent": "NA",
+  "region": "California",
+  "city": "Los Angeles",
+  "asn": "12345",
+  "ver": 1
+}
+```
 
-Signature check order: **sign → hashSign → workerSign → ipSign**
+Use `CHECK_ORIGIN="asn"`, `CHECK_ORIGIN="country,iprange"`, etc. to decide which fields must match the current request. Set `CHECK_ORIGIN=""` (default) to disable origin binding globally. Specific paths can bypass the binding via the new `skip-origin` action.
 
-Each check is independent and controlled by its corresponding CHECK flag (SIGN_CHECK, HASH_CHECK, WORKER_CHECK, IP_CHECK).
+`SIGN_CHECK`, `HASH_CHECK`, and `WORKER_CHECK` toggle the HMAC steps, while origin binding is governed exclusively by `CHECK_ORIGIN` + path actions.
 
 ## Path-based Access Control
 
@@ -110,8 +114,8 @@ Control access to specific paths using blacklist and whitelist:
 | `skip-sign` | Skip sign verification only |
 | `skip-hash` | Skip hashSign verification only |
 | `skip-worker` | Skip workerSign verification only |
-| `skip-ip` | Skip ipSign verification only |
-| `asis` | Respect SIGN_CHECK, HASH_CHECK, WORKER_CHECK, IP_CHECK settings |
+| `skip-origin` | Skip origin binding (even if `CHECK_ORIGIN` is enabled) |
+| `asis` | Respect SIGN_CHECK, HASH_CHECK, WORKER_CHECK, and `CHECK_ORIGIN` settings |
 
 ### Priority Rules
 
@@ -143,7 +147,7 @@ All exception actions must use `-except` suffix:
 | `skip-sign-except` | Skip sign check for all paths EXCEPT those matching EXCEPT_PREFIX |
 | `skip-hash-except` | Skip hashSign check for all paths EXCEPT those matching EXCEPT_PREFIX |
 | `skip-worker-except` | Skip workerSign check for all paths EXCEPT those matching EXCEPT_PREFIX |
-| `skip-ip-except` | Skip ipSign check for all paths EXCEPT those matching EXCEPT_PREFIX |
+| `skip-origin-except` | Skip origin binding for all paths EXCEPT those matching EXCEPT_PREFIX |
 | `asis-except` | Use default settings for all paths EXCEPT those matching EXCEPT_PREFIX |
 
 #### Exception List Examples
@@ -162,11 +166,11 @@ EXCEPT_ACTION=block-except
 # Result: Return 403 for all paths EXCEPT /public and /shared
 ```
 
-**Require IP verification only for sensitive paths:**
+**Require origin binding only for sensitive paths:**
 ```env
 EXCEPT_PREFIX=/admin,/private
-EXCEPT_ACTION=skip-ip-except
-# Result: All paths skip IP check EXCEPT /admin and /private
+EXCEPT_ACTION=skip-origin-except
+# Result: All paths skip origin binding EXCEPT /admin and /private
 ```
 
 ### Configuration Examples
@@ -177,10 +181,10 @@ BLACKLIST_PREFIX=/admin,/api/internal,/private
 BLACKLIST_ACTION=block
 ```
 
-**Skip IP check for public content:**
+**Skip origin binding for public content:**
 ```env
 WHITELIST_PREFIX=/public,/shared
-WHITELIST_ACTION=skip-ip
+WHITELIST_ACTION=skip-origin
 ```
 
 **Allow unsigned access to specific paths:**
@@ -197,7 +201,7 @@ BLACKLIST_ACTION=block
 
 # Allow public paths with reduced checks
 WHITELIST_PREFIX=/public
-WHITELIST_ACTION=skip-ip
+WHITELIST_ACTION=skip-origin
 ```
 
 ## Integration with alist-landing-worker
@@ -218,21 +222,21 @@ The landing worker generates:
 - `sign` - Original path signature
 - `hashSign` - Base64-encoded path signature
 - `workerSign` - JSON.stringify({path, worker_addr}) signature
-- `ipSign` - JSON.stringify({path, ip}) signature
+- `additionalInfo` / `additionalInfoSign` - HMAC-protected payload that now includes `pathHash`, `filesize`, `expireTime`, `idle_timeout`, and the AES-GCM encrypted origin snapshot (`encrypt`)
 
-All four signatures must use the same `TOKEN` and `expire` value.
+All signatures and `additionalInfoSign` must use the same `TOKEN` and `expire` value. The download worker relies on `additionalInfo.encrypt` plus `CHECK_ORIGIN` to ensure the current visitor matches the snapshot issued by the landing worker.
 
 ### URL Format
 
 Download URL generated by landing worker:
 ```
-https://proxy-worker.workers.dev/path/to/file?sign=xxx&hashSign=yyy&workerSign=www&ipSign=zzz
+https://proxy-worker.workers.dev/path/to/file?sign=xxx&hashSign=yyy&workerSign=www&additionalInfo=aaa&additionalInfoSign=bbb
 ```
 
 ## Security Best Practices
 
 1. **Use strong TOKEN**: Generate a cryptographically secure random string
-2. **Enable all checks**: Keep SIGN_CHECK, HASH_CHECK, IP_CHECK all `true` by default
+2. **Enable all checks**: Keep SIGN_CHECK, HASH_CHECK, WORKER_CHECK enabled and set `CHECK_ORIGIN` (e.g., `asn`) whenever possible
 3. **Limit whitelist scope**: Only whitelist paths that truly need reduced security
 4. **Review blacklist regularly**: Ensure sensitive paths are properly blocked
 5. **Use HTTPS only**: Never use HTTP for worker URLs
@@ -249,10 +253,10 @@ https://proxy-worker.workers.dev/path/to/file?sign=xxx&hashSign=yyy&workerSign=w
 - Check that signatures haven't expired
 - Ensure path encoding is consistent
 
-### Error: "ipSign mismatch"
-- Verify client IP hasn't changed between landing and download
-- Check that ipSign format matches: `JSON.stringify({path, ip})`
-- Ensure both workers use the same TOKEN
+### Error: "origin mismatch" / "origin decrypt failed"
+- Confirm `additionalInfo` has not been stripped or modified by intermediate services
+- Make sure landing and download workers share the same `TOKEN` so AES keys match
+- Review `CHECK_ORIGIN` value and consider adding `skip-origin` for paths where geo/IP may legitimately change
 
 ### IPv6 users can't download
 - Set `IPV4_ONLY=false` if you want to support IPv6
diff --git a/env.example b/env.example
index 0dfb6a2..3a5440a 100644
--- a/env.example
+++ b/env.example
@@ -38,10 +38,16 @@ SIGN_CHECK=true
 # Set to "false" to skip hashSign verification
 HASH_CHECK=true
 
-# IP_CHECK (default: true)
-# Enable or disable ipSign parameter verification
-# Set to "false" to skip ipSign verification
-IP_CHECK=true
+# CHECK_ORIGIN (default: empty)
+# Comma-separated fields to enforce origin binding. Supported values:
+#   ip, iprange, country, continent, region, city, asn
+# Examples:
+#   CHECK_ORIGIN=asn
+#   CHECK_ORIGIN=country,asn
+#   CHECK_ORIGIN=iprange,asn
+# Leave empty ("") to disable origin binding globally. Use the skip-origin action
+# for per-path overrides when only select routes should bypass the check.
+CHECK_ORIGIN=
 
 # IPV4_ONLY (default: true)
 # Block IPv6 access and only allow IPv4
@@ -59,10 +65,13 @@ BLACKLIST_PREFIX=
 # BLACKLIST_ACTION (optional)
 # Action to take for blacklisted paths. Valid values:
 #   - block: Return 403 Forbidden, deny all access
-#   - skip-sign: Skip all signature checks (sign, hashSign, ipSign)
-#   - skip-hash: Only check sign, skip hashSign and ipSign
-#   - skip-ip: Check sign and hashSign, skip ipSign only
-#   - asis: Respect the SIGN_CHECK, HASH_CHECK, IP_CHECK settings
+#   - skip-sign: Skip sign verification only
+#   - skip-hash: Skip hashSign verification only
+#   - skip-worker: Skip workerSign verification only
+#   - skip-addition: Skip additionalInfo verification (unless CHECK_ORIGIN requires it)
+#   - skip-addition-expiretime: Skip expireTime validation inside additionalInfo
+#   - skip-origin: Skip origin binding even if CHECK_ORIGIN is enabled
+#   - asis: Respect SIGN/HASH/WORKER/CHECK_ORIGIN global settings
 # Example: BLACKLIST_ACTION=block
 BLACKLIST_ACTION=
 
@@ -74,12 +83,9 @@ WHITELIST_PREFIX=
 
 # WHITELIST_ACTION (optional)
 # Action to take for whitelisted paths. Valid values: (same as BLACKLIST_ACTION)
-#   - block: Return 403 Forbidden
-#   - skip-sign: Skip all signature checks
-#   - skip-hash: Only check sign, skip hashSign and ipSign
-#   - skip-ip: Check sign and hashSign, skip ipSign only
-#   - asis: Respect the CHECK settings
-# Example: WHITELIST_ACTION=skip-ip
+#   - block / skip-sign / skip-hash / skip-worker
+#   - skip-addition / skip-addition-expiretime / skip-origin / asis
+# Example: WHITELIST_ACTION=skip-origin
 WHITELIST_ACTION=
 
 # ===== Database & Cache Configuration =====
@@ -142,7 +148,7 @@ PG_ERROR_HANDLE=fail-closed
 
 # ===== Notes =====
 #
-# Signature Check Order: sign → hashSign → ipSign
+# Signature Check Order: sign → hashSign → workerSign → origin decrypt (when CHECK_ORIGIN is set)
 # - Skipping earlier checks automatically skips later ones
 #
 # Priority: Blacklist > Whitelist > Default (CHECK flags)
diff --git a/src/worker.js b/src/worker.js
index 632a0f5..d511dee 100644
--- a/src/worker.js
+++ b/src/worker.js
@@ -7,11 +7,12 @@ import { unifiedCheckD1 } from './unified-check-d1.js';
 import { unifiedCheckD1Rest } from './unified-check-d1-rest.js';
 import { scheduleAllCleanups } from './cleanup-scheduler.js';
 import { parseBoolean, parseInteger, parseNumber, parseWindowTime, extractHostname, matchHostnamePattern, applyVerifyHeaders, calculateIPSubnet, sha256Hash } from './utils.js';
+import { checkOriginMatch, decryptOriginSnapshot, getClientIp, parseCheckOriginEnv } from './origin-binding.js';
 
 // Configuration constants
 const REQUIRED_ENV = ['ADDRESS', 'TOKEN', 'WORKER_ADDRESS'];
-const VALID_ACTIONS = new Set(['block', 'skip-sign', 'skip-hash', 'skip-worker', 'skip-ip', 'skip-addition', 'skip-addition-expiretime', 'asis']);
-const VALID_EXCEPT_ACTIONS = new Set(['block-except', 'skip-sign-except', 'skip-hash-except', 'skip-worker-except', 'skip-ip-except', 'skip-addition-except', 'skip-addition-expiretime-except', 'asis-except']);
+const VALID_ACTIONS = new Set(['block', 'skip-sign', 'skip-hash', 'skip-worker', 'skip-addition', 'skip-addition-expiretime', 'skip-origin', 'asis']);
+const VALID_EXCEPT_ACTIONS = new Set(['block-except', 'skip-sign-except', 'skip-hash-except', 'skip-worker-except', 'skip-addition-except', 'skip-addition-expiretime-except', 'skip-origin-except', 'asis-except']);
 
 let ipRateLimitDisabledLogged = false;
 
@@ -460,6 +461,8 @@ const resolveConfig = (env = {}) => {
     console.warn('[Fair Queue] Disabled: HOST_PATTERNS empty or dbMode not configured');
   }
 
+  const originCheckModes = parseCheckOriginEnv(env.CHECK_ORIGIN);
+
   return {
     address: String(env.ADDRESS).trim(),
     token: String(env.TOKEN).trim(),
@@ -470,7 +473,6 @@ const resolveConfig = (env = {}) => {
     signCheck: parseBoolean(env.SIGN_CHECK, true),
     hashCheck: parseBoolean(env.HASH_CHECK, true),
     workerCheck: parseBoolean(env.WORKER_CHECK, true),
-    ipCheck: parseBoolean(env.IP_CHECK, true),
     additionCheck: parseBoolean(env.ADDITION_CHECK, true),
     additionExpireTimeCheck: parseBoolean(env.ADDITION_EXPIRETIME_CHECK, true),
     ipv4Only: parseBoolean(env.IPV4_ONLY, true),
@@ -506,6 +508,7 @@ const resolveConfig = (env = {}) => {
     initTables,
     idleTimeout: idleTimeoutSeconds,
     lastActiveTableName,
+    originCheckModes,
     fairQueueEnabled: actualFairQueueEnabled,
     fairQueueHostnamePatterns,
     fairQueueConfig: {
@@ -917,7 +920,11 @@ async function handleDownload(request, env, config, cacheManager, throttleManage
     return createErrorResponse(origin, 403, "access denied");
   }
 
-  const clientIP = request.headers.get("CF-Connecting-IP") || "";
+  const skipOriginByAction = actions.includes('skip-origin');
+  const needOriginCheck = !skipOriginByAction && config.originCheckModes.length > 0;
+
+  const clientIpValue = getClientIp(request);
+  const clientIP = clientIpValue || "";
 
   // CF Rate Limiter检查（第一道防线）
   if (config.enableCfRatelimiter) {
@@ -951,9 +958,8 @@ async function handleDownload(request, env, config, cacheManager, throttleManage
   let shouldCheckSign = config.signCheck;
   let shouldCheckHash = config.hashCheck;
   let shouldCheckWorker = config.workerCheck;
-  let shouldCheckIP = config.ipCheck;
-  let shouldCheckAddition = config.additionCheck;
-  let shouldCheckAdditionExpireTime = config.additionExpireTimeCheck;
+  let shouldCheckAddition = config.additionCheck || needOriginCheck;
+  let shouldCheckAdditionExpireTime = config.additionExpireTimeCheck || needOriginCheck;
   let dynamicIdleTimeout = null;
 
   // Apply action overrides (unless 'asis' is specified)
@@ -968,13 +974,10 @@ async function handleDownload(request, env, config, cacheManager, throttleManage
     if (actions.includes('skip-worker')) {
       shouldCheckWorker = false;
     }
-    if (actions.includes('skip-ip')) {
-      shouldCheckIP = false;
-    }
-    if (actions.includes('skip-addition')) {
+    if (actions.includes('skip-addition') && !needOriginCheck) {
       shouldCheckAddition = false;
     }
-    if (actions.includes('skip-addition-expiretime')) {
+    if (actions.includes('skip-addition-expiretime') && !needOriginCheck) {
       shouldCheckAdditionExpireTime = false;
     }
   }
@@ -1008,25 +1011,9 @@ async function handleDownload(request, env, config, cacheManager, throttleManage
     }
   }
 
-  // IpSign verification
-  const ipSign = url.searchParams.get("ipSign") ?? "";
-  if (shouldCheckIP) {
-    if (!ipSign) {
-      return createUnauthorizedResponse(origin, "ipSign missing");
-    }
-    if (!clientIP) {
-      return createUnauthorizedResponse(origin, "client ip missing");
-    }
-    const ipRange = calculateIPSubnet(clientIP, config.ipv4Suffix, config.ipv6Suffix) || clientIP || "";
-    const ipVerifyData = JSON.stringify({ path: path, ip: ipRange });
-    const ipVerifyResult = await verify("ipSign", ipVerifyData, ipSign, config.token);
-    if (ipVerifyResult !== "") {
-      return createUnauthorizedResponse(origin, ipVerifyResult);
-    }
-  }
-
   const additionalInfo = url.searchParams.get("additionalInfo") ?? "";
   const additionalInfoSign = url.searchParams.get("additionalInfoSign") ?? "";
+  let additionalPayload = null;
   if (shouldCheckAddition) {
     if (!additionalInfo) {
       return createUnauthorizedResponse(origin, "additionalInfo missing");
@@ -1045,7 +1032,6 @@ async function handleDownload(request, env, config, cacheManager, throttleManage
       return createUnauthorizedResponse(origin, "additionalInfo decode failed");
     }
 
-    let additionalPayload;
     try {
       additionalPayload = JSON.parse(decodedAdditional);
     } catch (_error) {
@@ -1086,6 +1072,38 @@ async function handleDownload(request, env, config, cacheManager, throttleManage
     }
   }
 
+  if (needOriginCheck) {
+    if (!additionalPayload || typeof additionalPayload !== 'object') {
+      return createUnauthorizedResponse(origin, "origin payload missing");
+    }
+    const encryptedSnapshot = typeof additionalPayload.encrypt === 'string' ? additionalPayload.encrypt : '';
+    if (!encryptedSnapshot) {
+      return createUnauthorizedResponse(origin, "origin encrypt missing");
+    }
+    const snapshot = await decryptOriginSnapshot(encryptedSnapshot, config.token);
+    if (!snapshot) {
+      console.warn('[Origin Binding] Failed to decrypt snapshot');
+      return createUnauthorizedResponse(origin, "origin decrypt failed");
+    }
+    const cf = request.cf || {};
+    const currentOrigin = {
+      ip_addr: clientIpValue || null,
+      country: cf.country,
+      continent: cf.continent,
+      region: cf.region,
+      city: cf.city,
+      asn: typeof cf.asn === 'undefined' || cf.asn === null ? undefined : String(cf.asn),
+    };
+    const originResult = checkOriginMatch(snapshot, currentOrigin, config.originCheckModes, {
+      ipv4Suffix: config.ipv4Suffix,
+      ipv6Suffix: config.ipv6Suffix,
+    });
+    if (!originResult.ok) {
+      console.warn('[Origin Binding] Mismatch:', originResult.failedFields);
+      return createUnauthorizedResponse(origin, "origin mismatch");
+    }
+  }
+
   // ========================================
   // UNIFIED CHECK (RTT 3→1 OPTIMIZATION)
   // ========================================
@@ -1815,7 +1833,7 @@ async function handleRequest(request, env, config, cacheManager, throttleManager
   const origin = request.headers.get("origin") ?? "*";
   // Check for IPv6 access if IPv4_ONLY is enabled
   if (config.ipv4Only) {
-    const clientIP = request.headers.get("CF-Connecting-IP") || "";
+    const clientIP = getClientIp(request) || "";
     if (isIPv6(clientIP)) {
       const safeHeaders = new Headers();
       safeHeaders.set("content-type", "application/json;charset=UTF-8");
diff --git a/wrangler.toml b/wrangler.toml
index 96320f7..698fe7b 100644
--- a/wrangler.toml
+++ b/wrangler.toml
@@ -23,14 +23,13 @@ compatibility_date = "2024-01-01"
 # SIGN_CHECK = "true"
 # HASH_CHECK = "true"
 # WORKER_CHECK = "true"
-# IP_CHECK = "true"
 # ADDITION_CHECK = "true"             # Require additionalInfo and additionalInfoSign, validate signature/path binding
 # ADDITION_EXPIRETIME_CHECK = "true"  # Validate expireTime field (only when ADDITION_CHECK is true)
 # IPV4_ONLY = "true"
 # BLACKLIST_PREFIX = "/private,/admin"
 # BLACKLIST_ACTION = "block"
 # WHITELIST_PREFIX = "/public"
-# WHITELIST_ACTION = "skip-ip"
+# WHITELIST_ACTION = "skip-origin"
 # EXCEPT_PREFIX = "/api,/system"
 # EXCEPT_ACTION = "block-except"
 #
@@ -93,7 +92,7 @@ compatibility_date = "2024-01-01"
 # # │ skip-sign       │ Skip sign parameter verification                     │
 # # │ skip-hash       │ Skip hashSign parameter verification                 │
 # # │ skip-worker     │ Skip workerSign parameter verification               │
-# # │ skip-ip         │ Skip ipSign parameter verification                   │
+# # │ skip-origin     │ Skip origin binding verification                     │
 # # │ asis            │ Keep original behavior. Cannot combine with others   │
 # # └─────────────────┴──────────────────────────────────────────────────────┘
 # #
@@ -105,7 +104,7 @@ compatibility_date = "2024-01-01"
 # # │ skip-sign-except│ Skip sign check for paths NOT in EXCEPT_PREFIX       │
 # # │ skip-hash-except│ Skip hash check for paths NOT in EXCEPT_PREFIX       │
 # # │ skip-worker-except│ Skip worker check for paths NOT in EXCEPT_PREFIX   │
-# # │ skip-ip-except  │ Skip IP check for paths NOT in EXCEPT_PREFIX         │
+# # │ skip-origin-except│ Skip origin binding for paths NOT in EXCEPT_PREFIX │
 # # │ asis-except     │ Use original behavior for paths NOT in EXCEPT_PREFIX │
 # # └─────────────────┴──────────────────────────────────────────────────────┘
 # #
@@ -137,7 +136,7 @@ compatibility_date = "2024-01-01"
 # #   BLACKLIST_PREFIX = "/private,/admin"
 # #   BLACKLIST_ACTION = "block"
 # #   WHITELIST_PREFIX = "/public"
-# #   WHITELIST_ACTION = "skip-ip,skip-worker"
+# #   WHITELIST_ACTION = "skip-origin,skip-worker"
 # #
 # # Example 2: Only allow specific paths, block everything else
 # #   EXCEPT_PREFIX = "/allowed,/safe"
@@ -147,7 +146,7 @@ compatibility_date = "2024-01-01"
 # #
 # # Example 3: Skip IP check for all except sensitive paths
 # #   EXCEPT_PREFIX = "/sensitive,/private"
-# #   EXCEPT_ACTION = "skip-ip-except"
+# #   EXCEPT_ACTION = "skip-origin-except"
 # #   # Paths matching /sensitive or /private → IP check enabled
 # #   # All other paths → IP check skipped
 # #
