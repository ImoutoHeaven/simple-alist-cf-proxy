name = "simple-alist-cf-proxy"
main = "dist/worker.js"
compatibility_date = "2024-01-01"

# Environment variables (configure these in Cloudflare Dashboard or use secrets)
# [vars]
# ADDRESS = "https://your-alist-server.com"
# TOKEN = "your-hmac-token"
# WORKER_ADDRESS = "https://your-worker.workers.dev"
# VERIFY_HEADER = ""
# VERIFY_SECRET = ""
# SIGN_CHECK = "true"
# HASH_CHECK = "true"
# WORKER_CHECK = "true"
# IP_CHECK = "true"
# ADDITION_CHECK = "true"             # Require additionalInfo and additionalInfoSign, validate signature/path binding
# ADDITION_EXPIRETIME_CHECK = "true"  # Validate expireTime field (only when ADDITION_CHECK is true)
# IPV4_ONLY = "true"
# BLACKLIST_PREFIX = "/private,/admin"
# BLACKLIST_ACTION = "block"
# WHITELIST_PREFIX = "/public"
# WHITELIST_ACTION = "skip-ip"
# EXCEPT_PREFIX = "/api,/system"
# EXCEPT_ACTION = "block-except"
#
# # ═══════════════════════════════════════════════════════════════
# # Path Filtering System - Priority & Action Reference
# # ═══════════════════════════════════════════════════════════════
# #
# # Priority Order (evaluated in this sequence):
# # 1. BLACKLIST (highest priority) - matches prefix → apply actions
# # 2. WHITELIST (second priority) - matches prefix → apply actions
# # 3. EXCEPT (third priority) - does NOT match prefix → apply actions (inverse logic)
# # 4. Default - no match → use global *_CHECK settings
# #
# # Available Actions (comma-separated, multiple allowed except for block/asis):
# # ┌─────────────────┬──────────────────────────────────────────────────────┐
# # │ Action          │ Description                                          │
# # ├─────────────────┼──────────────────────────────────────────────────────┤
# # │ block           │ Deny access (403). Cannot combine with other actions │
# # │ skip-sign       │ Skip sign parameter verification                     │
# # │ skip-hash       │ Skip hashSign parameter verification                 │
# # │ skip-worker     │ Skip workerSign parameter verification               │
# # │ skip-ip         │ Skip ipSign parameter verification                   │
# # │ asis            │ Keep original behavior. Cannot combine with others   │
# # └─────────────────┴──────────────────────────────────────────────────────┘
# #
# # Except Actions (must use -except suffix, inverse matching):
# # ┌─────────────────┬──────────────────────────────────────────────────────┐
# # │ Action          │ Description                                          │
# # ├─────────────────┼──────────────────────────────────────────────────────┤
# # │ block-except    │ Block paths NOT in EXCEPT_PREFIX                     │
# # │ skip-sign-except│ Skip sign check for paths NOT in EXCEPT_PREFIX       │
# # │ skip-hash-except│ Skip hash check for paths NOT in EXCEPT_PREFIX       │
# # │ skip-worker-except│ Skip worker check for paths NOT in EXCEPT_PREFIX   │
# # │ skip-ip-except  │ Skip IP check for paths NOT in EXCEPT_PREFIX         │
# # │ asis-except     │ Use original behavior for paths NOT in EXCEPT_PREFIX │
# # └─────────────────┴──────────────────────────────────────────────────────┘
# #
# # Examples:
# #
# # Example 1: Block private paths, allow public with reduced verification
# #   BLACKLIST_PREFIX = "/private,/admin"
# #   BLACKLIST_ACTION = "block"
# #   WHITELIST_PREFIX = "/public"
# #   WHITELIST_ACTION = "skip-ip,skip-worker"
# #
# # Example 2: Only allow specific paths, block everything else
# #   EXCEPT_PREFIX = "/allowed,/safe"
# #   EXCEPT_ACTION = "block-except"
# #   # Paths matching /allowed or /safe → normal checks
# #   # All other paths → blocked (403)
# #
# # Example 3: Skip IP check for all except sensitive paths
# #   EXCEPT_PREFIX = "/sensitive,/private"
# #   EXCEPT_ACTION = "skip-ip-except"
# #   # Paths matching /sensitive or /private → IP check enabled
# #   # All other paths → IP check skipped
# #
# # Example 4: Complex multi-level filtering
# #   BLACKLIST_PREFIX = "/blocked"
# #   BLACKLIST_ACTION = "block"
# #   WHITELIST_PREFIX = "/media"
# #   WHITELIST_ACTION = "skip-sign,skip-hash"
# #   EXCEPT_PREFIX = "/api,/system"
# #   EXCEPT_ACTION = "asis-except"
# #   # Priority: /blocked → 403
# #   #          /media → skip sign+hash checks
# #   #          All except /api,/system → use original *_CHECK settings
# #          /api,/system → default behavior

#
# # Database Mode for Download Link Cache
# # Options: "d1" (Cloudflare D1 Binding), "d1-rest" (Cloudflare D1 REST API), "custom-pg-rest" (Custom PostgreSQL + PostgREST)
# # If not set, caching is completely disabled (always call AList API)
# DB_MODE = ""
# DOWNLOAD_CACHE_TABLE = "DOWNLOAD_CACHE_TABLE"
# THROTTLE_PROTECTION_TABLE = "THROTTLE_PROTECTION"
# DOWNLOAD_IP_RATELIMIT_TABLE = "DOWNLOAD_IP_RATELIMIT_TABLE"
#
# # Link Cache TTL - how long to cache download links before re-fetching from AList
# # Format: {number}{unit} where unit is h (hour), m (minute), s (second)
# # Examples: "30m", "1h", "120s"
# # Default: "30m" (1800 seconds)
# LINK_TTL = "30m"
#
# # Cleanup Percentage - probability of triggering cache cleanup per request
# # Range: 0-100 (supports decimals, e.g., "0.1" = 0.1% chance)
# # Default: "1" (1% chance per request)
# # Cleanup removes records older than LINK_TTL * 2
# CLEANUP_PERCENTAGE = "1"
#
# # D1 (Cloudflare D1 Binding) Download Cache - requires DB_MODE="d1"
# # Note: You must also configure d1_databases binding below
# D1_DATABASE_BINDING = "DB"  # Optional, defaults to "DB"
#
# # D1 REST API Download Cache - requires DB_MODE="d1-rest"
# # Use this mode when you cannot use Workers binding (e.g., external API calls)
# D1_ACCOUNT_ID = "your-cloudflare-account-id"
# D1_DATABASE_ID = "your-d1-database-id"
# D1_API_TOKEN = "your-cloudflare-api-token"
#
# # Custom PostgreSQL + PostgREST Download Cache - requires DB_MODE="custom-pg-rest"
# # Use this mode when you have self-hosted PostgreSQL with PostgREST REST API
# # ⚠️ IMPORTANT: You MUST run init.sql on your PostgreSQL database first!
# #   - Creates required tables & stored procedures (see init.sql)
# POSTGREST_URL = "https://your-domain.com/postgrest"  # PostgREST API endpoint (without table name)
# # Note: VERIFY_HEADER and VERIFY_SECRET (already defined above) are used for PostgREST authentication
#
#
# # ═══════════════════════════════════════════════════════════════
# # Throttle Protection System - Prevent Repeated Requests to Failing Hostnames
# # ═══════════════════════════════════════════════════════════════
# #
# # Purpose: Protect against repeated requests to hostnames that are returning errors
# # (e.g., OneDrive throttling with 429, Google Drive service errors with 503)
# #
# # How it works:
# # 1. When a download URL returns 4xx/5xx, the hostname is marked as "protected"
# # 2. Subsequent requests to that hostname will return the cached error without fetching
# # 3. After the time window expires, requests resume normally
# # 4. If successful, protection is cleared automatically
# #
# # Requirements:
# # - DB_MODE must be set (d1, d1-rest, or custom-pg-rest)
# # - For custom-pg-rest: Run init.sql to create THROTTLE_PROTECTION table and stored procedures
# #
# # Configuration:
# THROTTLE_PROTECT_HOSTNAME = ""  # Comma-separated hostname patterns to protect
#                                  # Examples: "*.sharepoint.com,*.googleapis.com"
#                                  #   - "*.sharepoint.com" matches both "xxx.sharepoint.com" and "sharepoint.com"
#                                  #   - "example.com" matches only "example.com"
#                                  # Default: "" (disabled - no protection)
#
# THROTTLE_TIME_WINDOW = "60s"    # Time window for protection (format: {number}{unit})
#                                  # Units: s (seconds), m (minutes), h (hours)
#                                  # Examples: "30s", "5m", "1h"
#                                  # Default: "60s"
#                                  # After this time, requests will resume to check if service recovered
#
# THROTTLE_PROTECT_HTTP_CODE = "429,500,503"  # Status codes that trigger protection (comma-separated)
#                                             # Provide only the codes that should cause throttle protect writes
#                                             # Example: "500" or "429,500,503"
#                                             # Default: "429,500,503"

# # ═══════════════════════════════════════════════════════════════
# # IP Subnet Rate Limiting (database-backed)
# # ═══════════════════════════════════════════════════════════════
# #
# # WINDOW_TIME = "24h"                  # Counting window per subnet
# # IPSUBNET_WINDOWTIME_LIMIT = "100"    # Max requests per subnet within WINDOW_TIME
# # IPV4_SUFFIX = "/32"                  # IPv4 subnet mask applied before hashing
# # IPV6_SUFFIX = "/60"                  # IPv6 subnet mask applied before hashing
# # BLOCK_TIME = "10m"                   # Additional block duration after hitting the limit
# # PG_ERROR_HANDLE = "fail-closed"      # Use "fail-open" to bypass DB errors gracefully

# D1 Database Binding (for DB_MODE="d1")
# Uncomment and configure this section if using D1 binding mode
# [[d1_databases]]
# binding = "DB"  # Must match D1_DATABASE_BINDING env var (or use default "DB")
# database_name = "alist-cache-db"
# database_id = "your-d1-database-id"

# For local development, create a .dev.vars file with:
# ADDRESS=https://your-alist-server.com
# TOKEN=your-hmac-token
# WORKER_ADDRESS=https://your-worker.workers.dev
